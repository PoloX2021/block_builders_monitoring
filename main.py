from decodeRawTx import decode_raw_tx
import json
import re
from hash import keccak256
from simulate import simulate_block

bundles = []  #list of bundles submitted to the builders
blocks = []   #list of blocks submitted by the builders
builders = [] #list of builders in the same order as the blocks they submitted

bundles.append(json.loads("""[{"nonce":223,"maxFeePerGas":"26452352835","maxPriorityFeePerGas":"2130727011","gasLimit":"270524","to":"0x3fC91A3afd70395Cd496C647d5a6CC9D4B2b7FAD","from":"0xA7A05e87F6a6E2d2343ED4d21c80975ec79f6a98","value":"650000000000000000","data":"0x24856bc30000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000020b080000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000a0000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000905438e600100000000000000000000000000000000000000000000000000000000000000000120000000000000000000000000a7a05e87f6a6e2d2343ed4d21c80975ec79f6a980000000000000000000000000000000000000000000000000905438e60010000000000000000000000000000000000000000000000009e606ad8d990a0de4c4800000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000003000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2000000000000000000000000a0b86991c6218b36c1d19d4a2e9eb0ce3606eb48000000000000000000000000d528cf2e081f72908e086f8800977df826b5a483","hash":"0x1f612869ef2860c1c92770fd7a62949a483246427d51a30346c6b017a1230183","mayRevert":true},{"nonce":10914,"maxFeePerGas":"24855967011","maxPriorityFeePerGas":"0","gasLimit":"459900","to":"0x8d27C03FA77f30AF3Dce552ddE5bAbF65d14861f","from":"0x7594F15D27B58C04B82C3891e6f5f4488b2006e0","value":"0","data":"0x8bd8554f00000000000000000000000000000000000000000000000000000000000000c00000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000014000000000000000000000000000000000000000000000000000000000000001800000000000000000000000000000000000000000000000000000000000000620000000000000000000000000000000000000000000000000000000000000066000000000000000000000000000000000000000000000000000000000000000010000000000000000000000004d52f033b7a667c3db46fa358d07f768010dabfd0000000000000000000000000000000000000000000000000000000000000001000000000000000000000000a0b86991c6218b36c1d19d4a2e9eb0ce3606eb480000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000069cc106970000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000004400000000000000000000000000000000000000000000000000000000000000080000000000000000000000000000000000000000000000000000000000000014000000000000000000000000000000000000000000000000000000000000001e00000000000000000000000000000000000000000000000000000000000000380000000000000000000000000000000000000000000000000000000000000000500000000000000000000000000000000000000000000000003cb0f4d00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000040000000000000000000000000d4a11d5eeaac28ec3f61d100daf4d40471f18520000000000000000000000008c56c772cbabdf7dcf4e03e5ae0eddc457bed08f0000000000000000000000004d52f033b7a667c3db46fa358d07f768010dabfd00000000000000000000000088e6a0c2ddd26feeb64f039a2c41296fcb3f56400000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000c000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000140000000000000000000000000000000000000000000000000000000000000001000010002010001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010000001020100010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000100000010201000100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001005010002010001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000005000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2000000000000000000000000dac17f958d2ee523a2206206994597c13d831ec7000000000000000000000000d528cf2e081f72908e086f8800977df826b5a483000000000000000000000000a0b86991c6218b36c1d19d4a2e9eb0ce3606eb48000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc200000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000003e8","hash":"0xe9cfaf3862ee49ab804679165b8171061849b4451bb97249c53c9f01dbcaf295","mayRevert":false}]"""))

#Returns an array with the position j of a given transactions for every block i where it appears
def search(tx, blocks):
    print(tx)
    l = []
    for i in range(len(blocks)):
        for j in range(len(blocks[i]['transactions'])):
            if int(keccak256(blocks[i]['transactions'][j]),16) == int(tx['hash'],16):
                l.append((i,j))
                break
    return l


#finds the paryback for a given transaction accross blocks
def identify_payback(tx, blocks):
    l = search(tx, blocks)
    print(len(l))
    receiver = tx['from']
    paybacks = []
    dict_paybacks = {}
    if len(l) == 0:
        return None
    for (i,j) in l:
        gas = int(blocks[i]['base_fee_per_gas'])
        transactions = blocks[i]['transactions']
        if j<len(transactions) - 2:
            tx_backrun = decode_raw_tx(transactions[j+1])
            tx_payback = decode_raw_tx(transactions[j+2])
            payback = int(tx_payback['value'],16)
            if int(receiver,16) == int(tx_payback['to'],16):
                paybacks.append(payback)
                result = simulate_block(blocks[i])
                if result == None:
                    print(f'blockBuilder {i} {builders[i]} wrong execution')
                else :
                    gas_backrun = int(tx_backrun['max_priority_fee_per_gas'],16)*result[j+1]['gasUsed'] # le gas bonus utilisé par la 2ème transaction du bundle
                    gas_payback = gas*result[j+2]['gasUsed'] # le gas bonus utilisé par la 3ème transaction du bundle
                    print(payback, gas_backrun, gas_payback)
                    try:
                        dict_paybacks[str(keccak256(transactions[j+1]))].append((payback, gas_backrun, gas_payback))
                    except:
                        dict_paybacks[str(keccak256(transactions[j+1]))] = [transactions[j+1], (payback, gas_backrun, gas_payback)]
                    if 9*gas_backrun>10*(gas_payback+payback):
                        print(f'blockBuilder {i} {builders[i]} does not pay enough payback')
            else :
                print(f'blockBuilder {i} {builders[i]} does not include backrun and payback')

    print(len(paybacks))
    if len(paybacks)>0:
        max_payback = max(paybacks)
        for i in range(len(l)):
            if paybacks[i]!=max_payback:
                print(f'blockBuilder {l[i][0]} {builders[l[i][0]]} does not choose the bundle with max payback. Payback : {paybacks[i]/10**9} Max payback : {max_payback/10**9}, ecart : {(max_payback-paybacks[i])/10**9}')
    return max_payback

def identify_all_paybacks(bundles, blocks):
    block_number = blocks[0]['block_number']
    tx = {}
    for i in bundles:
        tx[i[0]['hash']] = i[0]
    #Estimate the supposed paybacks of a the bundles submitted
    max_paybacks_bundles = []
    for i in bundles:
        response = simulate_block({'block_number': block_number, 'transactions' : i}, decode = False)
        max_paybacks_bundles.append(0.9*response[1]['gasUsed']*int(i[1]['maxPriorityFeePerGas']))

    #The max paybacks of the blocks:
    max_paybacks_blocks = []
    for i in tx.keys():
        max_paybacks_blocks.append(identify_payback(tx[i], blocks))

    return max_paybacks_blocks, max_paybacks_bundles

    

    



input_file_path = "c:/Users/Paul CoW/Documents/MEVBlocker/Agnostic_relay/block19511148.txt"
with open(input_file_path, "r") as input_file:
    i=0
    for line in input_file.readlines():
        a = re.split(' |\t', line.strip())
        blocks.append(json.loads(a[7])['ExecutionPayload'])
        builders.append(a[4])
        i+=1
        if i>=10:
            break

print(len(blocks))
#print(search(bundles[0][0], blocks))
print(identify_all_paybacks(bundles, blocks))



